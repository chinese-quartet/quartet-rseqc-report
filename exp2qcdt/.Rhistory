### data input ---
countdata<-read.csv("../../rna-test-data/yu_test1/count.csv",header=T,row.names = 1)
fpkmdata<-read.csv("../../rna-test-data/yu_test1/fpkm.csv",header=T,row.names = 1)
logexpr<-apply(fpkmdata,2,function(x){log2(x+0.01)})
#group<-as.factor(sapply(strsplit(colnames(countdata),"\\."),function(x){x[1]}))
exprMat_count_M<-melt(as.matrix(countdata))
colnames(exprMat_count_M)[1:3]<-c("gene","library","count")
exprMat_count_M$sample<-sapply(strsplit(as.character(exprMat_count_M$library),"\\."),function(x){x[1]})
# filter genes
expd_M<-exprMat_count_M[which(exprMat_count_M$count>=3),] # file genes >= 3 counts
expd_pg<-data.frame(tapply(expd_M$gene,as.factor(paste(expd_M$gene,expd_M$sample)),length))
colnames(expd_pg)<-c("Num")
expd_pg$gene<-sapply(strsplit(as.character(rownames(expd_pg))," "),function(x){x[1]})
expd_pg$sample<-sapply(strsplit(as.character(rownames(expd_pg))," "),function(x){x[2]})
expdgene<-expd_pg
expdgene1<-expdgene[expdgene$Num>1,] # filter genes >= 2 replicates,
### RC ---
usample<-c("D5","D6","F7","M8")
sample_combn<-data.frame(
sampleA=rep("D6",3),
sampleB= c("D5","F7","M8"))
colnames(sample_combn)<-c("sampleA","sampleB")
sample_combn$compare<-paste(sample_combn$sampleB,"/",sample_combn$sampleA,sep="")
colnames(fpkmdata)==colnames(countdata)
meta_dat<-data.frame(
library=colnames(countdata),
sample=sapply(strsplit(colnames(countdata),"\\."),function(x){x[1]})
)
j=1
lst.library.sampleA=meta_dat$library[meta_dat$sample==sample_combn$sampleA[j]]
lst.library.sampleB=meta_dat$library[meta_dat$sample==sample_combn$sampleB[j]]
lst.library.forDEG <- c(lst.library.sampleA, lst.library.sampleB)
# expdgene1 keep gene counts >= 3 at least 2 replicates
ggs<-intersect(expdgene1$gene[expdgene1$sample==sample_combn$sampleA[j]],expdgene1$gene[expdgene1$sample==sample_combn$sampleB[j]])
# ggs intersection genes between D6 and D5
expr<-countdata[ggs,]
DEG.cal.D56<-c()
# output limma results
y.DEG <- DEGanalysis(expr[,lst.library.forDEG],
factor(as.character(meta_dat$sample[match(lst.library.forDEG,meta_dat$library)])))
y.DEG<-data.frame(y.DEG)
y.DEG$compare<-paste(y.DEG$groupB,"/",y.DEG$groupA,sep="")
y.DEG_rev<-data.frame(
logFC= -y.DEG$logFC,
AveExpr=y.DEG$AveExpr,
t=y.DEG$t,
P.Value=y.DEG$P.Value,
adj.P.Val=y.DEG$adj.P.Val,
B=y.DEG$B,
gene=y.DEG$gene,
groupA=y.DEG$groupB,
groupB=y.DEG$groupA,
compare=rep(sample_combn$compare[j],nrow(y.DEG))
)
DEG.cal.D56<-y.DEG_rev
# mark up and down
DEG.cal.D56<-data.frame(DEG.cal.D56)
DEG.cal.D56$Type<-"non-DEG"
DEG.cal.D56$Type[intersect(which(DEG.cal.D56$P.Value<0.05),which(DEG.cal.D56$logFC>=1))]<-"up-regulate"
DEG.cal.D56$Type[intersect(which(DEG.cal.D56$P.Value<0.05),which(DEG.cal.D56$logFC<=(-1)))]<-"down-regulate"
?filterByExpr
#' Read reference data
#'
#' @param ref_data_dir A root directory for reference data
#' @return The reference data as a list.
#' @importFrom data.table fread
#' @export
read_ref_data <- function(ref_data_dir) {
# Read reference data
#
# Args:
#   None
#
# Returns:
#   ref_data
ref_data <- list()
ref_data$ref_qc_metrics_value <- fread(paste0(ref_data_dir, "/ref_data_qc_value.csv"))
ref_data$ref_fc_value <- fread(paste0(ref_data_dir, "/ref_data_fc_value.csv"))
return(ref_data)
}
#' This function is for identify DEG from a given matrix
#'
#' @param expr_mat should a matrix in stead of a data frame, with column for samples and rows for signature(gene/protein/metabolics...)
#'                 For transcriptome, a matrix after log transformation is recommended.
#' @param group    should be a factor whose length is identical to the number of the columns in expr_mat,
#'                 describing the group information of each column in expr_mat
#' @importFrom edgeR DGEList
#' @importFrom edgeR filterByExpr
#' @importFrom edgeR calcNormFactors
#' @importFrom limma voom
#' @importFrom limma lmFit
#' @importFrom limma eBayes
#' @importFrom limma topTable
#' @importFrom data.table as.data.table
#' @export
DEGanalysis <- function(exprMat, group){
dge <- DGEList(counts = exprMat)
design <- model.matrix(~group)
keep <- filterByExpr(dge, design, design,min.count = 0)
dge <- dge[keep,,keep.lib.sizes=FALSE]
dge <- calcNormFactors(dge)
v <- voom(dge, design, plot=F)
fit <- lmFit(v, design)
fit <- eBayes(fit)
result <- topTable(fit, coef=ncol(design), sort.by = 'logFC', number = Inf)
result$gene = rownames(result)
result$groupA =  levels(group)[1]
result$groupB =  levels(group)[2]
return(as.data.table(result))
}
#' Make a custom theme
#'
#' @return A custom theme
#' @importFrom ggplot2 theme
#' @importFrom ggplot2 element_text
#' @importFrom ggplot2 element_rect
#' @importFrom ggplot2 element_blank
#' @export
#'
make_theme <- function() {
custom_theme <- theme(plot.background = element_rect(colour = "white"),
axis.title.y = element_text(size = 16),
axis.title.x = element_text(size = 16),
axis.text.y = element_text(colour = "black", size = 16),
axis.text.x = element_text(colour = "black", size = 16),
title = element_text(colour = "black", size = 16),
panel.background = element_rect(fill = "white"),
panel.grid = element_blank(),
strip.text = element_text(size = 16))
return(custom_theme)
}
#' Make scatter and box figure
#' @importFrom ggplot2 ggplot
#' @importFrom ggplot2 scale_color_manual
#' @importFrom ggplot2 aes_string
#' @importFrom ggthemes theme_few
#' @importFrom cowplot insert_xaxis_grob
#' @export
plot_scatter_box <- function(dt_sb, var_x, var_y, col_g, xlab, ylab, title_lab){
colors_fill = c(Reference= "#2f5c85", QC = "#7ba1c7", Query = "red")
pmain <- ggplot(dt_sb, aes_string(x = var_x, y = var_y, color = col_g)) +
geom_point() +
scale_color_manual(values = colors_fill) +
theme_few() +
theme(legend.position = "none") +
labs(title = title_lab, x = xlab, y = ylab)
xplot <- ggplot(dt_sb, aes_string(x = col_g, y = var_x, colour = col_g)) +
geom_boxplot() +
scale_color_manual(values = colors_fill) +
coord_flip() +
theme_classic()
yplot <- ggplot(dt_sb, aes_string(x = col_g, y = var_y, colour = col_g)) +
geom_boxplot() +
scale_color_manual(values = colors_fill) +
theme_classic()
p1 <- insert_xaxis_grob(pmain, xplot, grid::unit(.2, "null"), position = "top")
p2 <- insert_yaxis_grob(p1, yplot, grid::unit(.2, "null"), position = "right")
pt_sb <- ggdraw(p2)
return(pt_sb)
}
#' S1-6 SNR
#'
#' @importFrom data.table setkey
#' @importFrom stats predict
#' @export
#'
calc_signoise_ratio <- function(pca_prcomp, exp_design) {
pcs <- as.data.frame(predict(pca_prcomp))
dt_perc_pcs <- data.table(PCX = 1:nrow(pcs),
Percent = summary(pca_prcomp)$importance[2,],
AccumPercent = summary(pca_prcomp)$importance[3,])
dt_dist <- data.table(ID.A = rep(rownames(pcs), each = nrow(pcs)),
ID.B = rep(rownames(pcs), time = nrow(pcs)))
dt_dist$Group.A <- exp_design[dt_dist$ID.A]$group
dt_dist$Group.B <- exp_design[dt_dist$ID.B]$group
dt_dist[, Type := ifelse(ID.A == ID.B, "Same",
ifelse(Group.A == Group.B, "Intra", "Inter"))]
dt_dist[, Dist := dt_perc_pcs[1]$Percent * (pcs[ID.A, 1] - pcs[ID.B, 1]) ^ 2 + dt_perc_pcs[2]$Percent * (pcs[ID.A, 2] - pcs[ID.B, 2]) ^ 2]
dt_dist_stats <- dt_dist[, .(Avg.Dist = mean(Dist)), by = .(Type)]
setkey(dt_dist_stats, Type)
signoise <- dt_dist_stats["Inter"]$Avg.Dist / dt_dist_stats["Intra"]$Avg.Dist
signoise_db <- 10*log10(signoise)
return(signoise_db)
}
#' Get PCA list
#'
#' @importFrom stats prcomp
#' @export
get_pca_list <- function(expr_mat_forsignoise, exp_design, dt_meta) {
pca_prcomp = prcomp(t(expr_mat_forsignoise), scale = F)
pcs = predict(pca_prcomp) %>% data.frame()
pcs$library = row.names(pcs)
pcs_add_meta = merge(pcs, dt_meta, by = "library")
PC1_ratio = round(summary(pca_prcomp)$importance[2, 1] * 100, digits = 2)
PC2_ratio = round(summary(pca_prcomp)$importance[2, 2] * 100, digits = 2)
PC3_ratio = round(summary(pca_prcomp)$importance[2, 3] * 100, digits = 2)
SNR = format(round(calc_signoise_ratio(pca_prcomp, exp_design = exp_design), digits = 3), nsmall = 3)
gene_num = dim(expr_mat_forsignoise)[1]
pca_list = cbind(pcs_add_meta, PC1_ratio, PC2_ratio, PC3_ratio, SNR, gene_num)
return(pca_list)
}
#' Make the performance score figure
#'
#' @param result_dir A directory for result files
#' @param sample_num The number of samples
#' @importFrom dplyr %>%
#' @importFrom data.table data.table
#' @importFrom ggplot2 ggplot
#' @importFrom ggplot2 geom_tile
#' @importFrom ggplot2 scale_fill_manual
#' @importFrom ggplot2 annotate
#' @importFrom ggplot2 theme_void
#' @importFrom ggplot2 theme
#' @importFrom ggplot2 aes
#' @importFrom ggplot2 arrow
#' @importFrom ggplot2 margin
#' @importFrom RColorBrewer brewer.pal
#' @importFrom grDevices colorRampPalette
#' @importFrom grDevices dev.off
#' @importFrom grDevices pdf
#' @importFrom grid unit
#' @export
make_score_figure <- function(result_dir, dt_hq_score_scale) {
# dt_hq_score_scale shold contain batch colname and quality score
dt_hq_score_scale_order <- dt_hq_score_scale[order(dt_hq_score_scale$total_score, decreasing = TRUE),]
dt_pscore <- data.table(cbind("score", dt_hq_score_scale_order[, .(total_score, batch)]))
setnames(dt_pscore, "V1", "type")
dt_pscore$total_score <- as.character(round(dt_pscore$total_score, digits = 2))
test_score <- dt_pscore[.("QC_test"), on = .(batch)][["total_score"]]
# plot
pdf(paste(result_dir, "/performance_assessment/performance_score.pdf", sep = ""), 4, 4)
pt <- ggplot(dt_pscore, aes(x = total_score, y = type, fill = total_score)) +
geom_tile(color = "white", show.legend = FALSE) +
scale_fill_manual(values = colorRampPalette(brewer.pal(9, "RdYlGn"))(21)) +
annotate(geom = "curve", x = test_score,
y = 2.5, xend = test_score, curvature = 0,
yend = 1.5, arrow = arrow(angle = 45, length = unit(9, "mm"), type = "closed"), color = "grey") +
annotate(geom = "text", x = dt_pscore[.("QC_test"), on = .(batch)][["total_score"]],
y = 2.2, label = test_score, hjust = "center", size = 10, fontface = "bold") +
theme_void() +
theme(plot.margin = margin(3, 0, 4, 0, "cm"))
print(pt)
dev.off()
}
result_dir <- '/Users/stead/JS_data/source_tree/project_code/plan_publish/chinese_quartet/report/rna-test-data/results'
# fpkm table path
exp_table_file <- '/Users/stead/JS_data/source_tree/project_code/plan_publish/chinese_quartet/report/rna-test-data/fpkm.csv'
# counts table path
count_table_file <- '/Users/stead/JS_data/source_tree/project_code/plan_publish/chinese_quartet/report/rna-test-data/count.csv'
# phenotype table path
# phenotype contain three colnames: library, group, sample
phenotype_file <- '/Users/stead/JS_data/source_tree/project_code/plan_publish/chinese_quartet/report/rna-test-data/metadata.csv'
exp2qcdt(exp_table_file, count_table_file, phenotype_file, result_dir)
dirs <- sapply(c("performance_assessment", "rawqc", "post_alignment_qc", "quantification_qc", "simplified_report"), function(subdir) {
return(file.path(workdir, subdir))
})
ref_data_dir <- paste(system.file(package = "exp2qcdt"), "/data", sep = "")
# Global variable
# TODO: This is not a good choice, maybe have another solution
ref_data <<- read_ref_data(ref_data_dir)
dt_fpkm <- fread(exp_table_file)
dt_counts <- fread(count_table_file)
dt_meta <- fread(phenotype_file)
# Prepare directories
make_directories(result_dir)
if(colnames(dt_fpkm)[1] != 'gene_id'|colnames(dt_counts)[1] != 'gene_id'){
colnames(dt_fpkm)[1] = 'gene_id'
colnames(dt_counts)[1] = 'gene_id'
}
if(!all(colnames(dt_counts) == colnames(dt_fpkm))){
stop('Please ensure that sample id of fpkm, counts and meta files in the same order')
}
# expression data type must be numeric
change_cols <- colnames(dt_fpkm[, !'gene_id'])
dt_fpkm[, (change_cols):= lapply(.SD, as.numeric), .SDcols = change_cols]
dt_counts[, (change_cols):= lapply(.SD, as.numeric), .SDcols = change_cols]
dt_fpkm_log <- data.table(apply(dt_fpkm[, !'gene_id'], 2, function(x)(log2(x + 0.01))))
dt_fpkm_log[, gene_id := dt_fpkm$gene_id]
#' Read reference data
#'
#' @param ref_data_dir A root directory for reference data
#' @return The reference data as a list.
#' @importFrom data.table fread
#' @export
read_ref_data <- function(ref_data_dir) {
# Read reference data
#
# Args:
#   None
#
# Returns:
#   ref_data
ref_data <- list()
ref_data$ref_qc_metrics_value <- fread(paste0(ref_data_dir, "/ref_data_qc_value.csv"))
ref_data$ref_fc_value <- fread(paste0(ref_data_dir, "/ref_data_fc_value.csv"))
return(ref_data)
}
#' This function is for identify DEG from a given matrix
#'
#' @param expr_mat should a matrix in stead of a data frame, with column for samples and rows for signature(gene/protein/metabolics...)
#'                 For transcriptome, a matrix after log transformation is recommended.
#' @param group    should be a factor whose length is identical to the number of the columns in expr_mat,
#'                 describing the group information of each column in expr_mat
#' @importFrom edgeR DGEList
#' @importFrom edgeR filterByExpr
#' @importFrom edgeR calcNormFactors
#' @importFrom limma voom
#' @importFrom limma lmFit
#' @importFrom limma eBayes
#' @importFrom limma topTable
#' @importFrom data.table as.data.table
#' @export
DEGanalysis <- function(exprMat, group){
dge <- DGEList(counts = exprMat)
design <- model.matrix(~group)
keep <- filterByExpr(dge, design, design,min.count = 0)
dge <- dge[keep,,keep.lib.sizes=FALSE]
dge <- calcNormFactors(dge)
v <- voom(dge, design, plot=F)
fit <- lmFit(v, design)
fit <- eBayes(fit)
result <- topTable(fit, coef=ncol(design), sort.by = 'logFC', number = Inf)
result$gene = rownames(result)
result$groupA =  levels(group)[1]
result$groupB =  levels(group)[2]
return(as.data.table(result))
}
#' Make a custom theme
#'
#' @return A custom theme
#' @importFrom ggplot2 theme
#' @importFrom ggplot2 element_text
#' @importFrom ggplot2 element_rect
#' @importFrom ggplot2 element_blank
#' @export
#'
make_theme <- function() {
custom_theme <- theme(plot.background = element_rect(colour = "white"),
axis.title.y = element_text(size = 16),
axis.title.x = element_text(size = 16),
axis.text.y = element_text(colour = "black", size = 16),
axis.text.x = element_text(colour = "black", size = 16),
title = element_text(colour = "black", size = 16),
panel.background = element_rect(fill = "white"),
panel.grid = element_blank(),
strip.text = element_text(size = 16))
return(custom_theme)
}
#' Make scatter and box figure
#' @importFrom ggplot2 ggplot
#' @importFrom ggplot2 scale_color_manual
#' @importFrom ggplot2 aes_string
#' @importFrom ggthemes theme_few
#' @importFrom cowplot insert_xaxis_grob
#' @export
plot_scatter_box <- function(dt_sb, var_x, var_y, col_g, xlab, ylab, title_lab){
colors_fill = c(Reference= "#2f5c85", QC = "#7ba1c7", Query = "red")
pmain <- ggplot(dt_sb, aes_string(x = var_x, y = var_y, color = col_g)) +
geom_point() +
scale_color_manual(values = colors_fill) +
theme_few() +
theme(legend.position = "none") +
labs(title = title_lab, x = xlab, y = ylab)
xplot <- ggplot(dt_sb, aes_string(x = col_g, y = var_x, colour = col_g)) +
geom_boxplot() +
scale_color_manual(values = colors_fill) +
coord_flip() +
theme_classic()
yplot <- ggplot(dt_sb, aes_string(x = col_g, y = var_y, colour = col_g)) +
geom_boxplot() +
scale_color_manual(values = colors_fill) +
theme_classic()
p1 <- insert_xaxis_grob(pmain, xplot, grid::unit(.2, "null"), position = "top")
p2 <- insert_yaxis_grob(p1, yplot, grid::unit(.2, "null"), position = "right")
pt_sb <- ggdraw(p2)
return(pt_sb)
}
#' S1-6 SNR
#'
#' @importFrom data.table setkey
#' @importFrom stats predict
#' @export
#'
calc_signoise_ratio <- function(pca_prcomp, exp_design) {
pcs <- as.data.frame(predict(pca_prcomp))
dt_perc_pcs <- data.table(PCX = 1:nrow(pcs),
Percent = summary(pca_prcomp)$importance[2,],
AccumPercent = summary(pca_prcomp)$importance[3,])
dt_dist <- data.table(ID.A = rep(rownames(pcs), each = nrow(pcs)),
ID.B = rep(rownames(pcs), time = nrow(pcs)))
dt_dist$Group.A <- exp_design[dt_dist$ID.A]$group
dt_dist$Group.B <- exp_design[dt_dist$ID.B]$group
dt_dist[, Type := ifelse(ID.A == ID.B, "Same",
ifelse(Group.A == Group.B, "Intra", "Inter"))]
dt_dist[, Dist := dt_perc_pcs[1]$Percent * (pcs[ID.A, 1] - pcs[ID.B, 1]) ^ 2 + dt_perc_pcs[2]$Percent * (pcs[ID.A, 2] - pcs[ID.B, 2]) ^ 2]
dt_dist_stats <- dt_dist[, .(Avg.Dist = mean(Dist)), by = .(Type)]
setkey(dt_dist_stats, Type)
signoise <- dt_dist_stats["Inter"]$Avg.Dist / dt_dist_stats["Intra"]$Avg.Dist
signoise_db <- 10*log10(signoise)
return(signoise_db)
}
#' Get PCA list
#'
#' @importFrom stats prcomp
#' @export
get_pca_list <- function(expr_mat_forsignoise, exp_design, dt_meta) {
pca_prcomp = prcomp(t(expr_mat_forsignoise), scale = F)
pcs = predict(pca_prcomp) %>% data.frame()
pcs$library = row.names(pcs)
pcs_add_meta = merge(pcs, dt_meta, by = "library")
PC1_ratio = round(summary(pca_prcomp)$importance[2, 1] * 100, digits = 2)
PC2_ratio = round(summary(pca_prcomp)$importance[2, 2] * 100, digits = 2)
PC3_ratio = round(summary(pca_prcomp)$importance[2, 3] * 100, digits = 2)
SNR = format(round(calc_signoise_ratio(pca_prcomp, exp_design = exp_design), digits = 3), nsmall = 3)
gene_num = dim(expr_mat_forsignoise)[1]
pca_list = cbind(pcs_add_meta, PC1_ratio, PC2_ratio, PC3_ratio, SNR, gene_num)
return(pca_list)
}
#' Make the performance score figure
#'
#' @param result_dir A directory for result files
#' @param sample_num The number of samples
#' @importFrom dplyr %>%
#' @importFrom data.table data.table
#' @importFrom ggplot2 ggplot
#' @importFrom ggplot2 geom_tile
#' @importFrom ggplot2 scale_fill_manual
#' @importFrom ggplot2 annotate
#' @importFrom ggplot2 theme_void
#' @importFrom ggplot2 theme
#' @importFrom ggplot2 aes
#' @importFrom ggplot2 arrow
#' @importFrom ggplot2 margin
#' @importFrom RColorBrewer brewer.pal
#' @importFrom grDevices colorRampPalette
#' @importFrom grDevices dev.off
#' @importFrom grDevices pdf
#' @importFrom grid unit
#' @export
make_score_figure <- function(result_dir, dt_hq_score_scale) {
# dt_hq_score_scale shold contain batch colname and quality score
dt_hq_score_scale_order <- dt_hq_score_scale[order(dt_hq_score_scale$total_score, decreasing = TRUE),]
dt_pscore <- data.table(cbind("score", dt_hq_score_scale_order[, .(total_score, batch)]))
setnames(dt_pscore, "V1", "type")
dt_pscore$total_score <- as.character(round(dt_pscore$total_score, digits = 2))
test_score <- dt_pscore[.("QC_test"), on = .(batch)][["total_score"]]
# plot
pdf(paste(result_dir, "/performance_assessment/performance_score.pdf", sep = ""), 4, 4)
pt <- ggplot(dt_pscore, aes(x = total_score, y = type, fill = total_score)) +
geom_tile(color = "white", show.legend = FALSE) +
scale_fill_manual(values = colorRampPalette(brewer.pal(9, "RdYlGn"))(21)) +
annotate(geom = "curve", x = test_score,
y = 2.5, xend = test_score, curvature = 0,
yend = 1.5, arrow = arrow(angle = 45, length = unit(9, "mm"), type = "closed"), color = "grey") +
annotate(geom = "text", x = dt_pscore[.("QC_test"), on = .(batch)][["total_score"]],
y = 2.2, label = test_score, hjust = "center", size = 10, fontface = "bold") +
theme_void() +
theme(plot.margin = margin(3, 0, 4, 0, "cm"))
print(pt)
dev.off()
}
# import reference data
dt_ref_qc_metrics_value <- ref_data$ref_qc_metrics_value
dt_ref_fc_value <- ref_data$ref_fc_value
# two group which two replicates are need
sample_type_list <- dt_meta[['sample']] %>% unique()
### D5/D6, F7/D6, M8/D6 log2FC correlation with reference data (dt_ref_fc_value)  ------
compare_combn <- data.table(combn(sample_type_list, 2))
# logfc for test data
dt_fc_test <- do.call(rbind, lapply(list(c('D5', 'D6'), c('F7', 'D6'), c('M8', 'D6')), function(x){
compare_name <- paste(x[1], '/', x[2], sep = '')
### at least 2 replicate counts >= 3
dt_detect_gene <-  data.table(apply(dt_counts[, dt_meta[x[1], on = .(sample)][['library']], with = F], 1, function(x){length(which(x >= 3)) >= 2}),
apply(dt_counts[, dt_meta[x[2], on = .(sample)][['library']], with = F], 1, function(x){length(which(x >= 3)) >= 2}))
gene_list_com <- dt_counts[['gene_id']][apply(dt_detect_gene, 1, function(x){all(x)})]
dt_count_compare <- dt_counts[, c('gene_id', dt_meta[c(x[1], x[2]), on = .(sample)][['library']]), with = F]
dt_count_compare_com <- dt_count_compare[gene_list_com, on = .(gene_id)]
group_compare <- dt_meta[c(x[1], x[2]), on = .(sample)][['sample']]
group_compare[group_compare == x[1]] <- 'ZZZ'
group_compare[group_compare == x[2]] <- 'AAA'
# DEG analysis was perform with edger pakcages
deg_output <- DEGanalysis(dt_count_compare_com[, !'gene_id'], group_compare)
deg_output[, gene_id := dt_count_compare_com[as.numeric(deg_output$gene), 'gene_id']]
deg_output[, compare := compare_name]
deg_output_d <- deg_output[,c('gene_id', 'compare', 'logFC'), with = FALSE]
colnames(deg_output_d) <- c('gene', 'compare', 'meanlogFC')
return(deg_output_d)
}))
# get reference data set compared group
dt_fc_test[, gene_compare := paste(gene, compare, sep = '_')]
dt_ref_fc_value[, gene_compare := paste(gene, compare, sep = '_')]
dt_ref_fc_test <- dt_fc_test[dt_ref_fc_value, on = 'gene_compare', nomatch = 0]
dt_ref_fc_test_d <- dt_ref_fc_test[, c('gene', 'compare', 'meanlogFC', 'i.meanlogFC'), with = FALSE]
colnames(dt_ref_fc_test_d) <- c('gene', 'compare', 'meanlogFC_test', 'meanlogFC_ref')
# log2fc correlation output data
cor_log2fc <- format(round(cor(dt_ref_fc_test_d$meanlogFC_test, dt_ref_fc_test_d$meanlogFC_ref), digits = 3), nsmall = 3)
cor_log2fc
devtools::document()
devtools::build()
install.packages("../exp2qcdt_0.2.4.tar.gz", , repos = NULL, type = "source")
library(exp2qcdt)
### test1 --------------------------
result_dir <- '/Users/stead/JS_data/source_tree/project_code/plan_publish/chinese_quartet/report/rna-test-data/results'
# fpkm table path
exp_table_file <- '/Users/stead/JS_data/source_tree/project_code/plan_publish/chinese_quartet/report/rna-test-data/fpkm.csv'
# counts table path
count_table_file <- '/Users/stead/JS_data/source_tree/project_code/plan_publish/chinese_quartet/report/rna-test-data/count.csv'
# phenotype table path
# phenotype contain three colnames: library, group, sample
phenotype_file <- '/Users/stead/JS_data/source_tree/project_code/plan_publish/chinese_quartet/report/rna-test-data/metadata.csv'
exp2qcdt(exp_table_file, count_table_file, phenotype_file, result_dir)
devtools::document()
